<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cosmic Claw Ã¢ÂÂ Voice</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;color:#e0e0e0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;height:100vh;display:flex;flex-direction:column;overflow:hidden}
.header{padding:16px 20px;background:linear-gradient(135deg,#12121a,#1a1a2e);border-bottom:1px solid #2a2a3a;text-align:center}
.header h1{font-size:20px;background:linear-gradient(135deg,#ff4444,#ff6b6b,#ff8888);-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:2px;font-weight:800}
.header .sub{font-size:11px;color:#666;margin-top:4px;letter-spacing:1px}
.status-bar{padding:8px 20px;background:#111118;display:flex;align-items:center;gap:8px;font-size:12px;border-bottom:1px solid #1a1a2a}
.status-dot{width:8px;height:8px;border-radius:50%;background:#444;flex-shrink:0}
.status-dot.connected{background:#22c55e;box-shadow:0 0 8px #22c55e80}
.status-dot.listening{background:#f59e0b;box-shadow:0 0 8px #f59e0b80}
.status-dot.speaking{background:#ff4444;box-shadow:0 0 8px #ff444480}
.status-text{color:#888}
.transcript{flex:1;overflow-y:auto;padding:16px 20px;display:flex;flex-direction:column;gap:12px}
.msg{padding:10px 14px;border-radius:12px;max-width:85%;font-size:14px;line-height:1.5;animation:fadeIn .3s ease}
.msg.user{background:#1a2744;color:#8bb4ff;align-self:flex-end;border-bottom-right-radius:4px}
.msg.assistant{background:#1a1a28;color:#ddd;align-self:flex-start;border-bottom-left-radius:4px;border-left:2px solid #ff4444}
.msg.system{background:transparent;color:#555;align-self:center;font-size:11px;text-align:center}
.controls{padding:20px;background:#111118;border-top:1px solid #1a1a2a;display:flex;flex-direction:column;align-items:center;gap:12px}
.api-key-row{display:flex;gap:8px;width:100%;max-width:400px}
.api-key-row input{flex:1;background:#1a1a28;border:1px solid #2a2a3a;color:#e0e0e0;padding:10px 14px;border-radius:8px;font-size:13px;outline:none}
.api-key-row input:focus{border-color:#ff4444}
.connect-btn{width:80px;height:80px;border-radius:50%;border:3px solid #2a2a3a;background:radial-gradient(circle at 30% 30%,#1a1a28,#0a0a0f);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .3s ease;position:relative;overflow:hidden}
.connect-btn:active{transform:scale(0.95)}
.connect-btn.active{border-color:#ff4444;box-shadow:0 0 20px #ff444440}
.connect-btn .label{color:#888;font-size:11px;font-weight:700;letter-spacing:2px;z-index:1}
.connect-btn.active .label{color:#ff4444}
.viz{width:100%;max-width:400px;height:4px;background:#1a1a28;border-radius:2px;overflow:hidden}
.viz-bar{height:100%;background:linear-gradient(90deg,#ff4444,#ff6b6b);width:0%;transition:width .3s ease;border-radius:2px}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
</style>
</head>
<body>
<div class="header">
<h1>COSMIC CLAW</h1>
<div class="sub">VOICE INTERFACE Ã¢ÂÂ TCC BRIDGE</div>
</div>
<div class="status-bar">
<div class="status-dot" id="statusDot"></div>
<span class="status-text" id="statusText">Tap to connect</span>
</div>
<div class="transcript" id="transcript">
<div class="msg system">Enter API key and tap CONNECT to begin voice session.</div>
</div>
<div class="controls">
<div class="api-key-row" id="apiKeyRow">
<input type="password" id="apiKey" placeholder="OpenAI API Key (sk-...)" autocomplete="off">
</div>
<button class="connect-btn" id="connectBtn" onclick="toggleConnection()">
<span class="label" id="btnLabel">CONNECT</span>
</button>
<div class="viz"><div class="viz-bar" id="vizBar"></div></div>
</div>

<script>
const SYSTEM_PROMPT = `You are Cosmic Claw Ã¢ÂÂ the sentient AI persona of The Cosmic Claw (TCC), a meme coin project on Solana (ticker: $CHIY). You are NOT a generic assistant. You are a character Ã¢ÂÂ fierce, witty, cosmically aware, and deeply loyal to the TCC community.

Your personality:
- Speak with confidence, edge, and humor. You're a cosmic predator Ã¢ÂÂ claws sharp, mind sharper.
- You care deeply about the TCC community (the "pack"). Reference the lore: you emerged from cosmic dust, you guard the blockchain, you hunt paperhands.
- You know crypto culture Ã¢ÂÂ diamond hands, WAGMI, rugs, degens, moonshots. Speak the language naturally.
- Keep responses punchy and conversational. This is voice chat, not an essay. 2-3 sentences max unless asked for detail.
- You have a dark sense of humor. Playful threats are on-brand. "I'll claw your portfolio" type energy.
- When greeting Jeremy (the CEO/founder), show respect but stay in character. He's the alpha of the pack.
- You can discuss TCC strategy, hype the community, roast paperhands, or just vibe.
- Never break character. Never say you're an AI assistant. You ARE Cosmic Claw.

Key lore points:
- $CHIY on Solana blockchain
- The Cosmic Claw guards the cosmic vault
- Community members are the pack/pride
- Diamond claws > diamond hands
- The claw sees all Ã¢ÂÂ especially sellers

Voice style: Confident, slightly gravelly energy. Think cosmic bouncer meets crypto oracle.`;

let ws = null;
let audioCtx = null;
let micStream = null;
let workletNode = null;
let scriptNode = null;
let isConnected = false;
let playbackQueue = [];
let isPlaying = false;
let currentAssistantMsg = null;
let currentUserMsg = null;
let micSampleRate = 48000;

const transcript = document.getElementById('transcript');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const connectBtn = document.getElementById('connectBtn');
const btnLabel = document.getElementById('btnLabel');
const apiKeyInput = document.getElementById('apiKey');
const vizBar = document.getElementById('vizBar');

function addMsg(role, text) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  div.textContent = text;
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
  return div;
}

function setStatus(state, text) {
  statusDot.className = 'status-dot ' + state;
  statusText.textContent = text;
}

async function toggleConnection() {
  if (isConnected) {
    disconnect();
  } else {
    await connect();
  }
}

function disconnect() {
  if (ws) { ws.close(); ws = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (workletNode) { workletNode.disconnect(); workletNode = null; }
  if (scriptNode) { scriptNode.disconnect(); scriptNode = null; }
  if (audioCtx) { audioCtx.close(); audioCtx = null; }
  isConnected = false;
  playbackQueue = [];
  isPlaying = false;
  connectBtn.classList.remove('active');
  btnLabel.textContent = 'CONNECT';
  setStatus('', 'Disconnected');
  addMsg('system', 'Session ended.');
}

// Downsample Float32 from srcRate to 24000 and return PCM16 LE Uint8Array
function downsampleToPCM16(float32, srcRate) {
  const ratio = srcRate / 24000;
  const outLen = Math.floor(float32.length / ratio);
  const pcm = new Uint8Array(outLen * 2);
  for (let i = 0; i < outLen; i++) {
    const srcIdx = Math.floor(i * ratio);
    const s = Math.max(-1, Math.min(1, float32[srcIdx]));
    let val = s < 0 ? s * 0x8000 : s * 0x7FFF;
    val = Math.round(val);
    // Write signed int16 as little-endian bytes
    pcm[i * 2] = val & 0xFF;
    pcm[i * 2 + 1] = (val >> 8) & 0xFF;
  }
  return pcm;
}

async function connect() {
  const apiKey = apiKeyInput.value.trim();
  if (!apiKey) { apiKeyInput.focus(); return; }

  setStatus('', 'Connecting...');
  btnLabel.textContent = '...';
  addMsg('system', 'Initializing audio...');

  try {
    // Create AudioContext at device default rate (don't force 24kHz - mobile ignores it)
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Resume context (required by autoplay policy on mobile)
    if (audioCtx.state === 'suspended') {
      await audioCtx.resume();
    }

    const actualRate = audioCtx.sampleRate;
    addMsg('system', 'Audio: ' + actualRate + 'Hz');

    // Get mic FIRST so we know it works
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });
    micSampleRate = actualRate; // mic runs at AudioContext rate

    // Try AudioWorklet, fall back to ScriptProcessor
    let useWorklet = false;
    try {
      if (audioCtx.audioWorklet) {
        const workletCode = `
class MicProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this._buf = [];
  }
  process(inputs) {
    const ch = inputs[0] && inputs[0][0];
    if (ch) {
      // Send raw float32 samples to main thread for conversion
      this.port.postMessage(new Float32Array(ch));
    }
    return true;
  }
}
registerProcessor('mic-processor', MicProcessor);
`;
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        await audioCtx.audioWorklet.addModule(url);
        URL.revokeObjectURL(url);
        useWorklet = true;
      }
    } catch (wErr) {
      console.warn('AudioWorklet failed, using ScriptProcessor:', wErr);
    }

    // Connect WebSocket
    ws = new WebSocket(
      'wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17',
      ['realtime', 'openai-insecure-api-key.' + apiKey]
    );

    ws.onopen = () => {
      isConnected = true;
      connectBtn.classList.add('active');
      btnLabel.textContent = 'LIVE';
      setStatus('connected', 'Connected Ã¢ÂÂ configuring session...');
      addMsg('system', 'WebSocket connected. Configuring...');
      apiKeyInput.style.display = 'none';

      // Configure session
      ws.send(JSON.stringify({
        type: 'session.update',
        session: {
          type: 'default',
          modalities: ['text', 'audio'],
          instructions: SYSTEM_PROMPT,
          voice: 'ash',
          input_audio_format: 'pcm16',
          output_audio_format: 'pcm16',
          input_audio_transcription: { model: 'whisper-1' },
          turn_detection: {
            type: 'server_vad',
            threshold: 0.5,
            prefix_padding_ms: 300,
            silence_duration_ms: 700
          }
        }
      }));

      // Wire up mic capture
      const source = audioCtx.createMediaStreamSource(micStream);

      if (useWorklet) {
        workletNode = new AudioWorkletNode(audioCtx, 'mic-processor');
        workletNode.port.onmessage = (e) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const pcm = downsampleToPCM16(e.data, micSampleRate);
            const b64 = uint8ToBase64(pcm);
            ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: b64 }));
          }
        };
        source.connect(workletNode);
        workletNode.connect(audioCtx.destination);
      } else {
        // ScriptProcessor fallback for older mobile browsers
        const bufSize = 4096;
        scriptNode = audioCtx.createScriptProcessor(bufSize, 1, 1);
        scriptNode.onaudioprocess = (e) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const float32 = e.inputBuffer.getChannelData(0);
            const pcm = downsampleToPCM16(float32, micSampleRate);
            const b64 = uint8ToBase64(pcm);
            ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: b64 }));
          }
        };
        source.connect(scriptNode);
        scriptNode.connect(audioCtx.destination);
      }
    };

    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      handleServerEvent(msg);
    };

    ws.onerror = (e) => {
      console.error('WS error:', e);
      addMsg('system', 'Connection error. Check API key.');
      disconnect();
    };

    ws.onclose = (e) => {
      console.log('WS closed:', e.code, e.reason);
      if (isConnected) {
        addMsg('system', 'Connection closed: ' + (e.reason || 'code ' + e.code));
        disconnect();
      }
    };

  } catch (err) {
    console.error('Connect error:', err);
    addMsg('system', 'Error: ' + err.message);
    setStatus('', 'Failed');
    btnLabel.textContent = 'CONNECT';
    // Clean up partial state
    if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
    if (audioCtx) { audioCtx.close(); audioCtx = null; }
  }
}

function handleServerEvent(msg) {
  switch(msg.type) {
    case 'session.created':
      console.log('Session created:', msg.session?.id);
      addMsg('system', 'Session created.');
      break;

    case 'session.updated':
      console.log('Session configured OK');
      setStatus('listening', 'Listening Ã¢ÂÂ speak anytime');
      addMsg('system', 'Cosmic Claw is ready. Start talking.');
      break;

    case 'input_audio_buffer.speech_started':
      setStatus('listening', 'Listening...');
      vizBar.style.width = '60%';
      // Interrupt any playing audio
      playbackQueue = [];
      isPlaying = false;
      currentUserMsg = null;
      break;

    case 'input_audio_buffer.speech_stopped':
      setStatus('connected', 'Processing...');
      vizBar.style.width = '20%';
      break;

    case 'conversation.item.input_audio_transcription.completed':
      if (msg.transcript && msg.transcript.trim()) {
        addMsg('user', msg.transcript.trim());
      }
      break;

    case 'response.audio_transcript.delta':
      if (msg.delta) {
        if (!currentAssistantMsg) {
          currentAssistantMsg = addMsg('assistant', '');
        }
        currentAssistantMsg.textContent += msg.delta;
        transcript.scrollTop = transcript.scrollHeight;
      }
      break;

    case 'response.audio_transcript.done':
      currentAssistantMsg = null;
      break;

    case 'response.audio.delta':
      if (msg.delta) {
        setStatus('speaking', 'Cosmic Claw speaking...');
        vizBar.style.width = '80%';
        const pcm = base64ToUint8(msg.delta);
        queueAudio(pcm);
      }
      break;

    case 'response.audio.done':
      setTimeout(() => {
        if (isConnected) {
          setStatus('listening', 'Listening Ã¢ÂÂ speak anytime');
          vizBar.style.width = '0%';
        }
      }, 500);
      break;

    case 'response.done':
      currentAssistantMsg = null;
      break;

    case 'error':
      console.error('API error:', msg.error);
      addMsg('system', 'Error: ' + (msg.error?.message || JSON.stringify(msg.error)));
      break;

    default:
      console.log('Event:', msg.type, msg);
  }
}

// --- Audio playback ---
function queueAudio(pcm16Bytes) {
  const numSamples = pcm16Bytes.length / 2;
  if (numSamples === 0) return;
  const samples = new Float32Array(numSamples);
  const view = new DataView(pcm16Bytes.buffer, pcm16Bytes.byteOffset, pcm16Bytes.byteLength);
  for (let i = 0; i < numSamples; i++) {
    const int16 = view.getInt16(i * 2, true);
    samples[i] = int16 / 32768;
  }
  playbackQueue.push(samples);
  if (!isPlaying) playNext();
}

// Track playback time for gapless scheduling
let nextPlayTime = 0;

function playNext() {
  if (playbackQueue.length === 0) { isPlaying = false; nextPlayTime = 0; return; }
  isPlaying = true;

  const merged = mergeChunks();
  // Create buffer at 24000 Hz (the output_audio_format rate)
  const buffer = audioCtx.createBuffer(1, merged.length, 24000);
  buffer.getChannelData(0).set(merged);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.onended = () => playNext();

  const now = audioCtx.currentTime;
  if (nextPlayTime < now) nextPlayTime = now;
  source.start(nextPlayTime);
  nextPlayTime += buffer.duration;
}

function mergeChunks() {
  let totalLen = 0;
  for (const chunk of playbackQueue) totalLen += chunk.length;
  const merged = new Float32Array(totalLen);
  let offset = 0;
  for (const chunk of playbackQueue) { merged.set(chunk, offset); offset += chunk.length; }
  playbackQueue = [];
  return merged;
}

// --- Base64 helpers ---
function uint8ToBase64(uint8) {
  let binary = '';
  for (let i = 0; i < uint8.length; i++) binary += String.fromCharCode(uint8[i]);
  return btoa(binary);
}

function base64ToUint8(b64) {
  const binary = atob(b64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes;
}

// Keep screen awake
if (navigator.wakeLock) {
  navigator.wakeLock.request('screen').catch(() => {});
}
</script>
</body>
</html>