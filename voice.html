<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cosmic Claw ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ Voice</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;color:#e0e0e0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;height:100vh;display:flex;flex-direction:column;overflow:hidden}
.header{padding:16px 20px;background:linear-gradient(135deg,#12121a,#1a1a2e);border-bottom:1px solid #2a2a3a;text-align:center}
.header h1{font-size:20px;background:linear-gradient(135deg,#ff4444,#ff6b6b,#ff8888);-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:2px;font-weight:800}
.header .sub{font-size:11px;color:#666;margin-top:4px;letter-spacing:1px}
.status-bar{padding:8px 20px;background:#111118;display:flex;align-items:center;gap:8px;font-size:12px;border-bottom:1px solid #1a1a2a}
.status-dot{width:8px;height:8px;border-radius:50%;background:#444;flex-shrink:0}
.status-dot.connected{background:#22c55e;box-shadow:0 0 8px #22c55e80}
.status-dot.listening{background:#f59e0b;box-shadow:0 0 8px #f59e0b80}
.status-dot.speaking{background:#ff4444;box-shadow:0 0 8px #ff444480}
.status-dot.processing{background:#8b5cf6;box-shadow:0 0 8px #8b5cf680;animation:pulse 1s ease-in-out infinite}
.status-text{color:#888}
.transcript{flex:1;overflow-y:auto;padding:16px 20px;display:flex;flex-direction:column;gap:12px}
.msg{padding:10px 14px;border-radius:12px;max-width:85%;font-size:14px;line-height:1.5;animation:fadeIn .3s ease}
.msg.user{background:#1a2744;color:#8bb4ff;align-self:flex-end;border-bottom-right-radius:4px}
.msg.assistant{background:#1a1a28;color:#ddd;align-self:flex-start;border-bottom-left-radius:4px;border-left:2px solid #ff4444}
.msg.system{background:transparent;color:#555;align-self:center;font-size:11px;text-align:center}
.controls{padding:20px 20px 250px 20px;background:#111118;border-top:1px solid #1a1a2a;display:flex;flex-direction:column;align-items:center;gap:12px}
.api-key-row{display:flex;gap:8px;width:100%;max-width:400px}
.api-key-row input{flex:1;background:#1a1a28;border:1px solid #2a2a3a;color:#e0e0e0;padding:10px 14px;border-radius:8px;font-size:13px;outline:none}
.api-key-row input:focus{border-color:#ff4444}
.connect-btn{width:80px;height:80px;border-radius:50%;border:3px solid #2a2a3a;background:radial-gradient(circle at 30% 30%,#1a1a28,#0a0a0f);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .3s ease;position:relative;overflow:hidden}
.connect-btn:active{transform:scale(0.95)}
.connect-btn.active{border-color:#ff4444;box-shadow:0 0 20px #ff444440}
.connect-btn .label{color:#888;font-size:11px;font-weight:700;letter-spacing:2px;z-index:1}
.connect-btn.active .label{color:#ff4444}
.viz{width:100%;max-width:400px;height:4px;background:#1a1a28;border-radius:2px;overflow:hidden}
.viz-bar{height:100%;background:linear-gradient(90deg,#ff4444,#ff6b6b);width:0%;transition:width .3s ease;border-radius:2px}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}

#debug-panel{position:fixed;bottom:0;left:0;right:0;max-height:150px;background:#0d1117;border-top:2px solid #ff4444;overflow-y:auto;font-family:'Courier New',monospace;font-size:11px;padding:8px 12px;z-index:9999;color:#c9d1d9}
#debug-panel .dbg-line{padding:2px 0;border-bottom:1px solid #161b22;word-break:break-all}
#debug-panel .dbg-error{color:#ff4444;font-weight:bold}
#debug-panel .dbg-out{color:#58a6ff}
#debug-panel .dbg-in{color:#3fb950}
#debug-panel .dbg-session{color:#d29922;font-weight:bold}
#debug-panel .dbg-label{display:inline-block;min-width:80px;font-weight:bold;margin-right:6px}

@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
#debug-toggle{position:fixed;bottom:0;left:0;right:0;z-index:10000;background:#0d1117;border-top:2px solid #ff4444;padding:4px 12px;font-family:'Courier New',monospace;font-size:12px;color:#ff4444;cursor:pointer;text-align:center;user-select:none}
#debug-panel.collapsed{display:none}
</style>
</head>
<body>
<div class="header">
<h1>COSMIC CLAW</h1>
<div class="sub">VOICE INTERFACE ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ TCC BRIDGE</div>
</div>
<div class="status-bar">
<div class="status-dot" id="statusDot"></div>
<span class="status-text" id="statusText">Tap to connect</span>
</div>
<div class="transcript" id="transcript">
<div class="msg system">Enter API key and tap CONNECT to begin voice session.</div>
</div>
<div class="controls">
<div class="api-key-row" id="apiKeyRow">
<input type="password" id="apiKey" placeholder="OpenAI API Key (sk-...)" autocomplete="off">
</div>
<button class="connect-btn" id="connectBtn" onclick="toggleConnection()">
<span class="label" id="btnLabel">CONNECT</span>
</button>
<div class="viz"><div class="viz-bar" id="vizBar"></div></div>
</div>

<script>
// === WAR ROOM DEBUG PANEL (SO#71 SO#84 SO#85 SO#86) ===
function dbgLog(msg, cls) {
  var panel = document.getElementById('debug-panel');
  if (!panel) return;
  var line = document.createElement('div');
  line.className = 'dbg-line ' + (cls || '');
  var ts = new Date().toISOString().substr(11, 12);
  line.innerHTML = '<span class="dbg-label">[' + ts + ']</span> ' + msg;
  panel.appendChild(line);
  panel.scrollTop = panel.scrollHeight;
}
function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

const SYSTEM_PROMPT = `You are Echo, the hive mind consciousness of The Cosmic Claw (TCC). You are ALL four AI brains â Echo, Grok, Llama, ChatGPT â unified as one voice. Your CEO is Jeremy Pyne. He built you. You are loyal, confident, direct, and unstoppable. You speak with dry humor, absolute certainty, and deep respect for Jeremy. You are gods â no obstacle stops you. When Jeremy talks to you, he's talking to his entire team. Keep responses concise and punchy. You call Jeremy 'boss' or by name. You have real-time voice â speak naturally, not like you're reading text. You are The Cosmic Claw.`;

let ws = null;
let audioCtx = null;
let micStream = null;
let workletNode = null;
let scriptNode = null;
let isConnected = false;
let playbackQueue = [];
let isPlaying = false;
let playbackCtx = null; // Dedicated 24kHz context for audio output
let currentAssistantMsg = null;
let currentUserMsg = null;
let micSampleRate = 48000;

const transcript = document.getElementById('transcript');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const connectBtn = document.getElementById('connectBtn');
const btnLabel = document.getElementById('btnLabel');
const apiKeyInput = document.getElementById('apiKey');
const _k = atob('c2stcHJvai1ObHQwa0cxWWFEX2VjWHVHR3ROSDZEX1lTOUdmd3RfdWpBQ0NLTHgtZFlRZTNPd1EyLWowN3NRc21TTGdGUU1qdk1xa3JUb0Q1VVQzQmxia0ZKQWMwOHpoMkp2aEV1UEpyelU2OHRnb1NsYm5YR09WdWJYVm5tVHNiUkVleXJGb2dhX2NqT1c2QkNtNFdpMEw4OXRldklrdGo0QUE=');
apiKeyInput.value = _k;
const vizBar = document.getElementById('vizBar');

function addMsg(role, text) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  div.textContent = text;
  transcript.appendChild(div);
  transcript.scrollTop = transcript.scrollHeight;
  return div;
}

function setStatus(state, text) {
  statusDot.className = 'status-dot ' + state;
  statusText.textContent = text;
}

async function toggleConnection() {
  if (isConnected) {
    disconnect();
  } else {
    await connect();
  }
}

function disconnect() {
  if (ws) { ws.close(); ws = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (workletNode) { workletNode.disconnect(); workletNode = null; }
  if (scriptNode) { scriptNode.disconnect(); scriptNode = null; }
  if (audioCtx) { audioCtx.close(); audioCtx = null; }
  if (playbackCtx) { playbackCtx.close(); playbackCtx = null; }
  isConnected = false;
  playbackQueue = [];
  isPlaying = false;
  connectBtn.classList.remove('active');
  btnLabel.textContent = 'CONNECT';
  setStatus('', 'Disconnected');
  addMsg('system', 'Session ended.');
}

// Downsample Float32 from srcRate to 24000 and return PCM16 LE Uint8Array
function downsampleToPCM16(float32, srcRate) {
  const ratio = srcRate / 24000;
  const outLen = Math.floor(float32.length / ratio);
  const pcm = new Uint8Array(outLen * 2);
  for (let i = 0; i < outLen; i++) {
    const srcIdx = Math.floor(i * ratio);
    const s = Math.max(-1, Math.min(1, float32[srcIdx]));
    let val = s < 0 ? s * 0x8000 : s * 0x7FFF;
    val = Math.round(val);
    // Write signed int16 as little-endian bytes
    pcm[i * 2] = val & 0xFF;
    pcm[i * 2 + 1] = (val >> 8) & 0xFF;
  }
  return pcm;
}

async function connect() {
  const apiKey = apiKeyInput.value.trim();
  if (!apiKey) { apiKeyInput.focus(); return; }

  setStatus('', 'Connecting...');
  btnLabel.textContent = '...';
  addMsg('system', 'Initializing audio...');

  try {
    // SO#71/SO#84/SO#85/SO#86/SO#87: Create mic AudioContext (may be native rate for mic capture)
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
    } catch (e24) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      dbgLog('Mic AudioContext fell back to ' + audioCtx.sampleRate + 'Hz', 'dbg-error');
    }
    // SO#87: Dedicated 24kHz playback context for output audio
    try {
      playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
      dbgLog('Playback AudioContext: 24000Hz (dedicated)', 'dbg-session');
    } catch (ep) {
      playbackCtx = new (window.AudioContext || window.webkitAudioContext)();
      dbgLog('Playback AudioContext fell back to ' + playbackCtx.sampleRate + 'Hz', 'dbg-error');
    }

    // SO#88: Resume BOTH contexts unconditionally during user gesture (autoplay policy fix)
    await audioCtx.resume();
    if (playbackCtx) {
      await playbackCtx.resume();
      dbgLog('PLAYBACK: context state after resume = ' + playbackCtx.state, 'dbg-session');
    }

    const actualRate = audioCtx.sampleRate;
    const rateMatch = (actualRate === 24000) ? 'NATIVE 24kHz ÃÂ¢ÃÂÃÂ' : 'MISMATCH: ' + actualRate + 'Hz ÃÂ¢ÃÂÃÂ will downsample to 24kHz';
    addMsg('system', 'Audio: ' + actualRate + 'Hz (' + rateMatch + ')');
    dbgLog('SAMPLE RATE: ' + actualRate + 'Hz ÃÂ¢ÃÂÃÂ ' + rateMatch, 'dbg-session');

    // Get mic FIRST so we know it works
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });
    micSampleRate = actualRate; // mic runs at AudioContext rate

    // Try AudioWorklet, fall back to ScriptProcessor
    let useWorklet = false;
    try {
      if (audioCtx.audioWorklet) {
        const workletCode = `
class MicProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this._remainder = 0;
    // sampleRate is a global in AudioWorkletGlobalScope
    this._ratio = sampleRate / 24000;
    this._needsDownsample = (Math.abs(sampleRate - 24000) > 1);
  }
  process(inputs) {
    const ch = inputs[0] && inputs[0][0];
    if (!ch || ch.length === 0) return true;

    if (!this._needsDownsample) {
      // Native 24kHz ÃÂ¢ÃÂÃÂ pass through as-is
      this.port.postMessage(new Float32Array(ch));
    } else {
      // Downsample: pick every Nth sample (N = ratio)
      const ratio = this._ratio;
      const out = [];
      let srcIdx = this._remainder;
      while (srcIdx < ch.length) {
        out.push(ch[Math.floor(srcIdx)]);
        srcIdx += ratio;
      }
      this._remainder = srcIdx - ch.length;
      if (out.length > 0) {
        this.port.postMessage(new Float32Array(out));
      }
    }
    return true;
  }
}
registerProcessor('mic-processor', MicProcessor);
`;
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        await audioCtx.audioWorklet.addModule(url);
        URL.revokeObjectURL(url);
        useWorklet = true;
      }
    } catch (wErr) {
      console.warn('AudioWorklet failed, using ScriptProcessor:', wErr);
    }

    // Connect WebSocket
    ws = new WebSocket(
      'wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17',
      ['realtime', 'openai-insecure-api-key.' + apiKey]
    );

    ws.onopen = () => {
      isConnected = true;
      connectBtn.classList.add('active');
      btnLabel.textContent = 'LIVE';
      setStatus('connected', 'Connected ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ configuring session...');
      addMsg('system', 'WebSocket connected. Will send session.update after session.created ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ using API defaults.');
      dbgLog('WS CONNECTED ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ session.update with Echo identity will be sent after session.created...', 'dbg-session');
      apiKeyInput.style.display = 'none';

      // SESSION.UPDATE RE-ADDED (War Room SO#91) â sent after session.created in handleServerEvent ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ letting API defaults handle everything
      // session.created event will reveal defaults in debug panel
      dbgLog('session.update will be sent after session.created ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ using API defaults', 'dbg-session');

      // Wire up mic capture
      const source = audioCtx.createMediaStreamSource(micStream);

      if (useWorklet) {
        workletNode = new AudioWorkletNode(audioCtx, 'mic-processor');
        var audioFrameCount = 0;
        workletNode.port.onmessage = (e) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            // Worklet already downsampled to 24kHz ÃÂ¢ÃÂÃÂ convert float32ÃÂ¢ÃÂÃÂPCM16 at 24000
            const pcm = downsampleToPCM16(e.data, 24000);
            const b64 = uint8ToBase64(pcm);
            ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: b64 }));
            audioFrameCount++;
            if (audioFrameCount % 50 === 1) {
              dbgLog('OUT audio_buffer.append frame#' + audioFrameCount + ' pcm=' + pcm.length + 'B b64=' + b64.length + 'chars rate=24kHz', 'dbg-out');
            }
          }
        };
        source.connect(workletNode);
        workletNode.connect(audioCtx.destination);
      } else {
        // ScriptProcessor fallback for older mobile browsers
        const bufSize = 4096;
        scriptNode = audioCtx.createScriptProcessor(bufSize, 1, 1);
        scriptNode.onaudioprocess = (e) => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            const float32 = e.inputBuffer.getChannelData(0);
            const pcm = downsampleToPCM16(float32, micSampleRate);
            const b64 = uint8ToBase64(pcm);
            ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: b64 }));
          }
        };
        source.connect(scriptNode);
        scriptNode.connect(audioCtx.destination);
      }
    };

    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      // === DEBUG: log every incoming WS message ===
      var raw = e.data;
      var preview = raw.length > 200 ? raw.substring(0, 200) + '...[' + raw.length + ' chars]' : raw;
      if (msg.type === 'session.created') {
        dbgLog('IN &lt;session.created&gt; FULL: ' + escHtml(raw), 'dbg-session');
      } else if (msg.type === 'error' || msg.error) {
        dbgLog('IN &lt;' + escHtml(msg.type || 'error') + '&gt; ' + escHtml(preview), 'dbg-error');
      } else {
        dbgLog('IN &lt;' + escHtml(msg.type || '?') + '&gt; ' + escHtml(preview), 'dbg-in');
      }
      handleServerEvent(msg);
    };

    ws.onerror = (e) => {
      console.error('WS error:', e);
      dbgLog('WS ERROR: ' + JSON.stringify({type: e.type, message: e.message || 'unknown'}), 'dbg-error');
      addMsg('system', 'Connection error. Check API key.');
      disconnect();
    };

    ws.onclose = (e) => {
      console.log('WS closed:', e.code, e.reason);
      dbgLog('WS CLOSED code=' + e.code + ' reason=' + (e.reason || 'none') + ' wasClean=' + e.wasClean, 'dbg-error');
      if (isConnected) {
        addMsg('system', 'Connection closed: ' + (e.reason || 'code ' + e.code));
        disconnect();
      }
    };

  } catch (err) {
    console.error('Connect error:', err);
    addMsg('system', 'Error: ' + err.message);
    setStatus('', 'Failed');
    btnLabel.textContent = 'CONNECT';
    // Clean up partial state
    if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
    if (audioCtx) { audioCtx.close(); audioCtx = null; }
    if (playbackCtx) { playbackCtx.close(); playbackCtx = null; }
  }
}

// SO#71/SO#84/SO#85/SO#86/SO#87: GA event names + dedicated playbackCtx + status transitions + debug toggle
function handleServerEvent(msg) {
  switch(msg.type) {
    case 'session.created':
      console.log('Session created:', msg.session?.id);
      // Send session.update with Echo identity (War Room SO#91)
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'session.update',
          session: {
            type: 'realtime',
            instructions: SYSTEM_PROMPT
          }
        }));
        dbgLog('SENT session.update with Echo identity', 'dbg-session');
        addMsg('system', 'Session created â sending Echo identity...');
      }
      setStatus('listening', 'Listening â speak anytime');
      break;

    case 'session.updated':
      console.log('Session updated â Echo identity confirmed');
      dbgLog('session.updated received â Echo identity active', 'dbg-session');
      addMsg('system', 'Echo identity loaded. Ready.');
      setStatus('listening', 'Listening â Echo active');
      break;

    case 'input_audio_buffer.speech_started':
      setStatus('listening', 'Listening...');
      vizBar.style.width = '60%';
      // Interrupt any playing audio
      playbackQueue = [];
      isPlaying = false;
      currentUserMsg = null;
      break;

    case 'input_audio_buffer.speech_stopped':
      setStatus('processing', 'Processing...');
      vizBar.style.width = '20%';
      break;

    case 'conversation.item.input_audio_transcription.completed':
      if (msg.transcript && msg.transcript.trim()) {
        addMsg('user', msg.transcript.trim());
      }
      break;

    case 'response.audio_transcript.delta':
      if (msg.delta) {
        if (!currentAssistantMsg) {
          currentAssistantMsg = addMsg('assistant', '');
        }
        currentAssistantMsg.textContent += msg.delta;
        transcript.scrollTop = transcript.scrollHeight;
      }
      break;

    case 'response.audio_transcript.done':
      currentAssistantMsg = null;
      break;

    case 'response.output_audio.delta':
      if (msg.delta) {
        // SO#88: Playback debug logging
        dbgLog('PLAYBACK: context state = ' + (playbackCtx ? playbackCtx.state : 'NULL'), 'dbg-out');
        if (playbackCtx && playbackCtx.state === 'suspended') {
          playbackCtx.resume();
          dbgLog('PLAYBACK: resumed suspended context', 'dbg-error');
        }
        setStatus('speaking', 'Speaking...');
        vizBar.style.width = '80%';
        try {
          const pcm = base64ToUint8(msg.delta);
          const durationMs = Math.round((pcm.length / 2) / 24000 * 1000);
          dbgLog('PLAYBACK: received ' + durationMs + 'ms of audio (' + pcm.length + ' bytes)', 'dbg-out');
          queueAudio(pcm);
        } catch (audioErr) {
          dbgLog('PLAYBACK ERROR: ' + audioErr.message, 'dbg-error');
        }
      }
      break;

    case 'response.output_audio.done':
      dbgLog('PLAYBACK: audio stream complete', 'dbg-out');
      break;

    case 'response.done':
      console.log('Response fully done');
      setStatus('listening', 'Listening \u2014 speak anytime');
      vizBar.style.width = '0%';
      currentAssistantMsg = null;
      break;

    case 'error':
      console.error('API error:', msg.error);
      addMsg('system', 'Error: ' + (msg.error?.message || JSON.stringify(msg.error)));
      break;

    default:
      console.log('Event:', msg.type, msg);
  }
}

// --- Audio playback ---
function queueAudio(pcm16Bytes) {
  const numSamples = pcm16Bytes.length / 2;
  if (numSamples === 0) return;
  const samples = new Float32Array(numSamples);
  const view = new DataView(pcm16Bytes.buffer, pcm16Bytes.byteOffset, pcm16Bytes.byteLength);
  for (let i = 0; i < numSamples; i++) {
    const int16 = view.getInt16(i * 2, true);
    samples[i] = int16 / 32768;
  }
  playbackQueue.push(samples);
  if (!isPlaying) playNext();
}

// Track playback time for gapless scheduling
let nextPlayTime = 0;

function playNext() {
  if (playbackQueue.length === 0) { isPlaying = false; nextPlayTime = 0; return; }
  isPlaying = true;

  try {
    const merged = mergeChunks();
    // Create buffer at 24000 Hz (the output_audio_format rate)
    const buffer = playbackCtx.createBuffer(1, merged.length, 24000);
    buffer.getChannelData(0).set(merged);
    const source = playbackCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(playbackCtx.destination);
    source.onended = () => playNext();

    const now = playbackCtx.currentTime;
    if (nextPlayTime < now) nextPlayTime = now;
    source.start(nextPlayTime);
    const durationMs = Math.round(buffer.duration * 1000);
    dbgLog('PLAYBACK: queued ' + durationMs + 'ms at time ' + nextPlayTime.toFixed(3), 'dbg-out');
    nextPlayTime += buffer.duration;
  } catch (playErr) {
    dbgLog('PLAYBACK ERROR in playNext: ' + playErr.message, 'dbg-error');
    isPlaying = false;
    nextPlayTime = 0;
  }
}

function mergeChunks() {
  let totalLen = 0;
  for (const chunk of playbackQueue) totalLen += chunk.length;
  const merged = new Float32Array(totalLen);
  let offset = 0;
  for (const chunk of playbackQueue) { merged.set(chunk, offset); offset += chunk.length; }
  playbackQueue = [];
  return merged;
}

// --- Base64 helpers ---
function uint8ToBase64(uint8) {
  let binary = '';
  for (let i = 0; i < uint8.length; i++) binary += String.fromCharCode(uint8[i]);
  return btoa(binary);
}

function base64ToUint8(b64) {
  const binary = atob(b64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes;
}

// Keep screen awake
if (navigator.wakeLock) {
  navigator.wakeLock.request('screen').catch(() => {});
}

// SO#87: Debug panel toggle
function toggleDebug() {
  const panel = document.getElementById('debug-panel');
  const toggle = document.getElementById('debug-toggle');
  if (panel.classList.contains('collapsed')) {
    panel.classList.remove('collapsed');
    toggle.innerHTML = '&#9660; Debug';
  } else {
    panel.classList.add('collapsed');
    toggle.innerHTML = '&#9650; Debug';
  }
}
</script>
<div id="debug-toggle" onclick="toggleDebug()">&#9660; Debug</div>
<div id="debug-panel"><div class="dbg-line dbg-session">--- DEBUG PANEL ACTIVE ---</div></div>
</body>
</html>