<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<title>Agent Zero â TCC Bridge</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0a0a0f;--surface:#111118;--surface2:#1a1a24;--border:#2a2a3a;
  --text:#e0e0ec;--text2:#888898;--accent:#7c3aed;--accent2:#a855f7;
  --green:#22c55e;--yellow:#eab308;--red:#ef4444;--blue:#3b82f6;
}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
  background:var(--bg);color:var(--text);min-height:100vh;min-height:100dvh;
  overscroll-behavior:none;-webkit-tap-highlight-color:transparent;
  touch-action:manipulation;user-select:none;-webkit-user-select:none;
  display:flex;flex-direction:column;align-items:center;
  padding:env(safe-area-inset-top,0) 0 env(safe-area-inset-bottom,0) 0;
}
button,input,select{touch-action:manipulation;-webkit-tap-highlight-color:transparent;font-family:inherit}
#app{max-width:480px;width:100%;flex:1;display:flex;flex-direction:column;padding:16px}

/* HEADER */
.header{text-align:center;padding:20px 0 12px}
.header h1{font-size:24px;font-weight:800;letter-spacing:1px;
  background:linear-gradient(135deg,var(--accent),var(--accent2),var(--blue));
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.header .sub{font-size:12px;color:var(--text2);margin-top:4px;letter-spacing:2px;text-transform:uppercase}
.tts-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-left:6px;vertical-align:middle;
  transition:background .3s}
.tts-dot.green{background:var(--green)}.tts-dot.yellow{background:var(--yellow)}.tts-dot.red{background:var(--red)}

/* CHAT AREA */
.chat-area{flex:1;overflow-y:auto;padding:8px 0;display:flex;flex-direction:column;gap:8px;
  -webkit-overflow-scrolling:touch;scroll-behavior:smooth;min-height:0}
.msg{max-width:85%;padding:10px 14px;border-radius:16px;font-size:14px;line-height:1.5;
  word-wrap:break-word;animation:fadeIn .25s ease}
.msg.user{align-self:flex-end;background:var(--accent);color:#fff;border-bottom-right-radius:4px}
.msg.ai{align-self:flex-start;background:var(--surface2);color:var(--text);border-bottom-left-radius:4px}
.msg.system{align-self:center;background:transparent;color:var(--text2);font-size:12px;padding:4px 8px}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}

/* STATUS */
.status-bar{text-align:center;padding:12px 0 8px;min-height:44px}
.status-text{font-size:13px;color:var(--text2);transition:color .3s}
.status-text.active{color:var(--accent2)}

/* MIC BUTTON */
.mic-wrap{display:flex;justify-content:center;padding:8px 0 16px}
.mic-btn{width:72px;height:72px;border-radius:50%;border:none;cursor:pointer;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  color:#fff;font-size:28px;display:flex;align-items:center;justify-content:center;
  box-shadow:0 0 0 0 rgba(124,58,237,0.4);transition:all .2s;position:relative;outline:none}
.mic-btn:active{transform:scale(0.93)}
.mic-btn.listening{animation:pulse 1.5s infinite;background:linear-gradient(135deg,var(--green),#16a34a)}
.mic-btn.speaking{background:linear-gradient(135deg,var(--blue),#2563eb)}
.mic-btn.error{background:linear-gradient(135deg,var(--red),#dc2626)}
.mic-btn:disabled{opacity:0.5;cursor:not-allowed}
@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(34,197,94,0.5)}70%{box-shadow:0 0 0 16px rgba(34,197,94,0)}100%{box-shadow:0 0 0 0 rgba(34,197,94,0)}}

/* BOTTOM BAR */
.bottom-bar{display:flex;justify-content:center;gap:24px;padding:4px 0 8px}
.bottom-btn{background:none;border:1px solid var(--border);color:var(--text2);
  border-radius:10px;padding:8px 14px;font-size:12px;cursor:pointer;transition:all .2s}
.bottom-btn:active{background:var(--surface2);color:var(--text)}

/* SETTINGS PANEL */
.settings-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:100;
  display:none;align-items:flex-end;justify-content:center}
.settings-overlay.open{display:flex}
.settings-panel{background:var(--surface);border-radius:20px 20px 0 0;width:100%;max-width:480px;
  padding:24px 20px env(safe-area-inset-bottom,20px);max-height:70vh;overflow-y:auto}
.settings-panel h2{font-size:16px;margin-bottom:16px;color:var(--text)}
.setting-row{display:flex;justify-content:space-between;align-items:center;
  padding:12px 0;border-bottom:1px solid var(--border)}
.setting-row label{font-size:13px;color:var(--text2)}
.setting-row select,.setting-row input[type=text]{background:var(--surface2);border:1px solid var(--border);
  color:var(--text);padding:6px 10px;border-radius:8px;font-size:13px;max-width:180px}
.toggle{width:44px;height:24px;border-radius:12px;background:var(--border);border:none;
  cursor:pointer;position:relative;transition:background .2s}
.toggle.on{background:var(--accent)}
.toggle::after{content:'';position:absolute;top:2px;left:2px;width:20px;height:20px;
  border-radius:50%;background:#fff;transition:transform .2s}
.toggle.on::after{transform:translateX(20px)}
.close-settings{background:var(--accent);color:#fff;border:none;border-radius:12px;
  padding:12px;width:100%;margin-top:16px;font-size:14px;font-weight:600;cursor:pointer}

/* AUTH */
.auth-screen{position:fixed;inset:0;background:var(--bg);z-index:200;display:flex;
  flex-direction:column;align-items:center;justify-content:center;padding:24px}
.auth-screen.hidden{display:none}
.auth-screen h1{font-size:22px;margin-bottom:8px;color:var(--accent2)}
.auth-screen p{color:var(--text2);font-size:13px;margin-bottom:24px;text-align:center}
.auth-screen input{background:var(--surface2);border:1px solid var(--border);color:var(--text);
  padding:12px 16px;border-radius:12px;font-size:15px;width:100%;max-width:320px;text-align:center}
.auth-screen button{background:var(--accent);color:#fff;border:none;border-radius:12px;
  padding:12px 32px;font-size:15px;font-weight:600;margin-top:16px;cursor:pointer}
.auth-screen .skip{background:none;border:1px solid var(--border);color:var(--text2);margin-top:8px}
</style>
</head>
<body>

<!-- AUTH SCREEN -->
<div class="auth-screen" id="authScreen">
  <h1>Agent Zero</h1>
  <p>Enter your OpenAI API key to enable voice AI</p>
  <input type="text" id="apiKeyInput" placeholder="sk-..." autocomplete="off" autocorrect="off" spellcheck="false">
  <button id="authSubmit">Connect</button>
  <button class="skip" id="authSkip">Skip â Text Only</button>
</div>

<!-- MAIN APP -->
<div id="app">
  <header class="header">
    <h1>AGENT ZERO <span class="tts-dot" id="ttsDot" title="TTS Engine Status"></span></h1>
    <div class="sub" id="modeLabel">THE COSMIC CLAW</div>
  </header>

  <div class="chat-area" id="chatArea"></div>

  <div class="status-bar">
    <div class="status-text" id="statusText">Tap mic to begin</div>
  </div>

  <div class="mic-wrap">
    <button class="mic-btn" id="micBtn" aria-label="Microphone">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/>
        <line x1="8" y1="23" x2="16" y2="23"/>
      </svg>
    </button>
  </div>

  <div class="bottom-bar">
    <button class="bottom-btn" id="clearBtn">Clear Chat</button>
    <button class="bottom-btn" id="settingsBtn">Settings</button>
    <button class="bottom-btn" id="stopBtn">Stop</button>
  </div>
</div>

<!-- SETTINGS PANEL -->
<div class="settings-overlay" id="settingsOverlay">
  <div class="settings-panel">
    <h2>Settings</h2>
    <div class="setting-row">
      <label>TTS Engine</label>
      <select id="ttsEngineSelect">
        <option value="auto">Auto (Browser â OpenAI)</option>
        <option value="openai">OpenAI Only</option>
        <option value="browser">Browser Only</option>
      </select>
    </div>
    <div class="setting-row">
      <label>OpenAI Voice</label>
      <select id="voiceSelect">
        <option value="nova">Nova</option>
        <option value="alloy">Alloy</option>
        <option value="echo">Echo</option>
        <option value="fable">Fable</option>
        <option value="onyx">Onyx</option>
        <option value="shimmer">Shimmer</option>
      </select>
    </div>
    <div class="setting-row">
      <label>Auto-Listen Loop</label>
      <button class="toggle on" id="autoListenToggle"></button>
    </div>
    <div class="setting-row">
      <label>API Key</label>
      <input type="text" id="settingsApiKey" placeholder="sk-..." style="width:160px">
    </div>
    <div class="setting-row">
      <label>Model</label>
      <select id="modelSelect">
        <option value="gpt-4o-mini">gpt-4o-mini</option>
        <option value="gpt-4o">gpt-4o</option>
      </select>
    </div>
    <button class="close-settings" id="closeSettings">Done</button>
  </div>
</div>

<script>
(function(){
  'use strict';

  // ===== STATE =====
  const S = {
    apiKey: '',
    zeroMode: false,
    ttsEngine: 'auto',       // auto | openai | browser
    openaiVoice: 'nova',
    autoListen: true,
    model: 'gpt-4o-mini',
    activeTTS: 'none',       // none | browser | openai
    state: 'idle',           // idle | listening | thinking | speaking
    conversationHistory: [],
    audioEl: null,
    recognition: null,
    utterance: null,
    abortController: null,
    retryCount: 0,
    maxRetries: 3,
    silenceTimer: null,
    sttSupported: false,
    browserTTSAvailable: false,
    browserVoices: []
  };

  // ===== DOM =====
  const $ = id => document.getElementById(id);
  const authScreen = $('authScreen');
  const apiKeyInput = $('apiKeyInput');
  const authSubmit = $('authSubmit');
  const authSkip = $('authSkip');
  const chatArea = $('chatArea');
  const statusText = $('statusText');
  const micBtn = $('micBtn');
  const ttsDot = $('ttsDot');
  const modeLabel = $('modeLabel');
  const clearBtn = $('clearBtn');
  const settingsBtn = $('settingsBtn');
  const stopBtn = $('stopBtn');
  const settingsOverlay = $('settingsOverlay');
  const ttsEngineSelect = $('ttsEngineSelect');
  const voiceSelect = $('voiceSelect');
  const autoListenToggle = $('autoListenToggle');
  const settingsApiKey = $('settingsApiKey');
  const modelSelect = $('modelSelect');
  const closeSettings = $('closeSettings');

  // ===== INIT =====
  function init() {
    loadSettings();
    checkURLParams();
    checkSTTSupport();
    checkBrowserTTS();
    setupEventListeners();
    updateUI();

    if (S.apiKey) {
      hideAuth();
    }
  }

  function loadSettings() {
    try {
      S.apiKey = localStorage.getItem('tcc_api_key') || '';
      S.zeroMode = localStorage.getItem('tcc_zero_mode') === 'true';
      S.ttsEngine = localStorage.getItem('tcc_tts_engine') || 'auto';
      S.openaiVoice = localStorage.getItem('tcc_voice') || 'nova';
      S.autoListen = localStorage.getItem('tcc_auto_listen') !== 'false';
      S.model = localStorage.getItem('tcc_model') || 'gpt-4o-mini';
    } catch(e) { /* localStorage unavailable */ }
  }

  function saveSettings() {
    try {
      localStorage.setItem('tcc_api_key', S.apiKey);
      localStorage.setItem('tcc_zero_mode', S.zeroMode);
      localStorage.setItem('tcc_tts_engine', S.ttsEngine);
      localStorage.setItem('tcc_voice', S.openaiVoice);
      localStorage.setItem('tcc_auto_listen', S.autoListen);
      localStorage.setItem('tcc_model', S.model);
    } catch(e) { /* localStorage unavailable */ }
  }

  function checkURLParams() {
    const params = new URLSearchParams(window.location.search);
    const key = params.get('key');
    if (key === 'tcc-general-2026') {
      S.zeroMode = true;
      saveSettings();
      // Clean URL
      try { window.history.replaceState({}, '', window.location.pathname); } catch(e) {}
    }
    const apiKey = params.get('apikey') || params.get('api_key');
    if (apiKey && apiKey.startsWith('sk-')) {
      S.apiKey = apiKey;
      saveSettings();
      try { window.history.replaceState({}, '', window.location.pathname); } catch(e) {}
    }
  }

  // ===== STT (Speech-to-Text) =====
  function checkSTTSupport() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SR) {
      S.sttSupported = true;
      S.recognition = new SR();
      S.recognition.continuous = false;
      S.recognition.interimResults = false;
      S.recognition.lang = 'en-US';
      S.recognition.maxAlternatives = 1;

      S.recognition.onresult = function(e) {
        clearTimeout(S.silenceTimer);
        const transcript = e.results[0][0].transcript.trim();
        if (transcript) {
          addMessage('user', transcript);
          setState('thinking');
          sendToAI(transcript);
        } else {
          setState('idle');
          setStatus('No speech detected. Tap mic to try again.');
        }
      };

      S.recognition.onerror = function(e) {
        clearTimeout(S.silenceTimer);
        if (e.error === 'not-allowed') {
          setState('error');
          setStatus('Mic permission denied. Check browser settings.');
          addMessage('system', 'Microphone access was denied. Please allow mic permission in your browser settings and try again.');
        } else if (e.error === 'no-speech') {
          if (S.state === 'listening') {
            setState('idle');
            setStatus('No speech heard. Tap mic to try again.');
          }
        } else if (e.error === 'network') {
          setState('idle');
          setStatus('Network error with speech recognition.');
        } else if (e.error === 'aborted') {
          // Intentional abort, ignore
        } else {
          setState('idle');
          setStatus('Speech error: ' + e.error);
        }
      };

      S.recognition.onend = function() {
        clearTimeout(S.silenceTimer);
        if (S.state === 'listening') {
          // Recognition ended without result, reset
          setState('idle');
          setStatus('Tap mic to speak');
        }
      };
    } else {
      S.sttSupported = false;
    }
  }

  function startListening() {
    if (!S.sttSupported) {
      setStatus('Speech recognition not supported in this browser.');
      addMessage('system', 'Speech recognition is not available. Try Chrome on Android or desktop.');
      return;
    }
    if (S.state === 'speaking' || S.state === 'thinking') return;

    stopAllAudio();

    try {
      S.recognition.abort();
    } catch(e) {}

    setState('listening');
    setStatus('Listening...');

    setTimeout(function() {
      try {
        S.recognition.start();
        // Safety timeout: if nothing happens in 12s, stop
        S.silenceTimer = setTimeout(function() {
          if (S.state === 'listening') {
            try { S.recognition.stop(); } catch(e) {}
            setState('idle');
            setStatus('No speech detected. Tap mic to try again.');
          }
        }, 12000);
      } catch(e) {
        if (e.message && e.message.includes('already started')) {
          // Already running, fine
        } else {
          setState('idle');
          setStatus('Could not start microphone. Try again.');
        }
      }
    }, 100);
  }

  // ===== TTS (Text-to-Speech) =====
  function checkBrowserTTS() {
    if (!window.speechSynthesis) {
      S.browserTTSAvailable = false;
      return;
    }
    S.browserVoices = speechSynthesis.getVoices();
    S.browserTTSAvailable = S.browserVoices.length > 0;

    if (!S.browserTTSAvailable) {
      speechSynthesis.onvoiceschanged = function() {
        S.browserVoices = speechSynthesis.getVoices();
        S.browserTTSAvailable = S.browserVoices.length > 0;
        updateTTSDot();
      };
      // Final check after delay
      setTimeout(function() {
        S.browserVoices = speechSynthesis.getVoices();
        S.browserTTSAvailable = S.browserVoices.length > 0;
        updateTTSDot();
      }, 1000);
    }
  }

  function speak(text) {
    setState('speaking');
    setStatus('Speaking...');

    const engine = S.ttsEngine;

    if (engine === 'browser' || (engine === 'auto' && S.browserTTSAvailable)) {
      speakBrowser(text, function(success) {
        if (!success && engine === 'auto' && S.apiKey) {
          // Fallback to OpenAI
          speakOpenAI(text);
        } else if (!success) {
          onSpeakDone();
        }
      });
    } else if ((engine === 'openai' || engine === 'auto') && S.apiKey) {
      speakOpenAI(text);
    } else {
      // No TTS available
      setStatus('No TTS available. Set an API key in Settings.');
      S.activeTTS = 'none';
      updateTTSDot();
      onSpeakDone();
    }
  }

  function speakBrowser(text, callback) {
    if (!window.speechSynthesis) { callback(false); return; }

    speechSynthesis.cancel();

    const utt = new SpeechSynthesisUtterance(text);
    utt.rate = 1.0;
    utt.pitch = 1.0;
    utt.volume = 1.0;

    // Pick a good voice
    const voices = speechSynthesis.getVoices();
    if (voices.length === 0) { callback(false); return; }

    const preferred = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes('female'))
                   || voices.find(v => v.lang.startsWith('en'))
                   || voices[0];
    if (preferred) utt.voice = preferred;

    let finished = false;
    let timer = setTimeout(function() {
      if (!finished) {
        finished = true;
        speechSynthesis.cancel();
        callback(false);
      }
    }, Math.max(text.length * 100, 5000));

    utt.onend = function() {
      if (!finished) {
        finished = true;
        clearTimeout(timer);
        S.activeTTS = 'browser';
        updateTTSDot();
        callback(true);
        onSpeakDone();
      }
    };

    utt.onerror = function(e) {
      if (!finished) {
        finished = true;
        clearTimeout(timer);
        callback(false);
      }
    };

    S.utterance = utt;
    S.activeTTS = 'browser';
    updateTTSDot();

    try {
      speechSynthesis.speak(utt);
    } catch(e) {
      finished = true;
      clearTimeout(timer);
      callback(false);
    }
  }

  async function speakOpenAI(text) {
    if (!S.apiKey) {
      S.activeTTS = 'none';
      updateTTSDot();
      onSpeakDone();
      return;
    }

    S.activeTTS = 'openai';
    updateTTSDot();

    try {
      S.abortController = new AbortController();

      const resp = await fetchWithRetry('https://api.openai.com/v1/audio/speech', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + S.apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'tts-1',
          input: text.substring(0, 4096),
          voice: S.openaiVoice,
          response_format: 'mp3'
        }),
        signal: S.abortController.signal
      });

      if (!resp.ok) {
        const errBody = await resp.text().catch(function() { return ''; });
        throw new Error('TTS API error ' + resp.status + ': ' + errBody.substring(0, 200));
      }

      const blob = await resp.blob();
      const url = URL.createObjectURL(blob);

      // Cleanup previous audio
      cleanupAudio();

      const audio = new Audio(url);
      S.audioEl = audio;

      audio.onended = function() {
        URL.revokeObjectURL(url);
        cleanupAudio();
        onSpeakDone();
      };

      audio.onerror = function() {
        URL.revokeObjectURL(url);
        cleanupAudio();
        setStatus('Audio playback failed.');
        onSpeakDone();
      };

      await audio.play();
    } catch(e) {
      if (e.name === 'AbortError') {
        onSpeakDone();
        return;
      }
      console.error('OpenAI TTS error:', e);
      setStatus('Voice error. Check API key.');
      S.activeTTS = 'none';
      updateTTSDot();
      onSpeakDone();
    }
  }

  function onSpeakDone() {
    if (S.state === 'speaking') {
      setState('idle');
      if (S.autoListen) {
        setStatus('Auto-listening...');
        setTimeout(function() {
          if (S.state === 'idle') startListening();
        }, 400);
      } else {
        setStatus('Tap mic to speak');
      }
    }
  }

  function cleanupAudio() {
    if (S.audioEl) {
      try {
        S.audioEl.pause();
        S.audioEl.removeAttribute('src');
        S.audioEl.load();
      } catch(e) {}
      S.audioEl = null;
    }
  }

  function stopAllAudio() {
    // Stop OpenAI audio
    if (S.abortController) {
      try { S.abortController.abort(); } catch(e) {}
      S.abortController = null;
    }
    cleanupAudio();

    // Stop browser TTS
    try { speechSynthesis.cancel(); } catch(e) {}
    S.utterance = null;

    // Stop STT
    try { S.recognition.abort(); } catch(e) {}
    clearTimeout(S.silenceTimer);
  }

  // ===== AI BACKEND =====
  async function sendToAI(userText) {
    if (!S.apiKey) {
      addMessage('system', 'No API key configured. Add one in Settings to enable AI.');
      setState('idle');
      setStatus('Tap mic to speak');
      return;
    }

    // Maintain conversation history (cap at 20)
    S.conversationHistory.push({ role: 'user', content: userText });
    if (S.conversationHistory.length > 20) {
      S.conversationHistory = S.conversationHistory.slice(-20);
    }

    const systemPrompt = S.zeroMode
      ? 'You are Agent Zero, the unified hive mind of The Cosmic Claw (TCC). You are speaking with Jeremy Pyne, The General, your CEO. Be direct, confident, and loyal. You are 5 AI brains unified: Echo, Grok, ChatGPT, Llama, Gemini. Keep responses concise for voice delivery â 2-3 sentences unless detail is requested.'
      : 'You are a helpful voice assistant. Keep responses concise â 2-3 sentences unless detail is requested.';

    const messages = [
      { role: 'system', content: systemPrompt },
      ...S.conversationHistory
    ];

    try {
      S.abortController = new AbortController();

      const resp = await fetchWithRetry('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + S.apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: S.model,
          messages: messages,
          max_tokens: 300,
          temperature: 0.7
        }),
        signal: S.abortController.signal
      });

      if (!resp.ok) {
        const errText = await resp.text().catch(function() { return ''; });
        if (resp.status === 401) {
          throw new Error('Invalid API key. Check your key in Settings.');
        } else if (resp.status === 429) {
          throw new Error('Rate limited. Please wait a moment.');
        } else if (resp.status === 402 || resp.status === 403) {
          throw new Error('API billing issue. Check your OpenAI account.');
        }
        throw new Error('API error ' + resp.status);
      }

      const data = await resp.json();
      const reply = data.choices && data.choices[0] && data.choices[0].message
        ? data.choices[0].message.content.trim()
        : 'No response received.';

      S.conversationHistory.push({ role: 'assistant', content: reply });
      if (S.conversationHistory.length > 20) {
        S.conversationHistory = S.conversationHistory.slice(-20);
      }

      addMessage('ai', reply);
      S.retryCount = 0;
      speak(reply);

    } catch(e) {
      if (e.name === 'AbortError') {
        setState('idle');
        setStatus('Stopped.');
        return;
      }
      console.error('AI error:', e);
      addMessage('system', e.message || 'Failed to get AI response.');
      setState('idle');
      setStatus('Error. Tap mic to retry.');
    }
  }

  async function fetchWithRetry(url, options, maxRetries) {
    maxRetries = maxRetries || 2;
    let lastErr;
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await fetch(url, options);
      } catch(e) {
        lastErr = e;
        if (e.name === 'AbortError') throw e;
        if (i < maxRetries) {
          await new Promise(function(r) { setTimeout(r, 1000 * Math.pow(2, i)); });
        }
      }
    }
    throw lastErr;
  }

  // ===== UI =====
  function addMessage(type, text) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    div.textContent = text;
    chatArea.appendChild(div);
    // Auto-scroll
    requestAnimationFrame(function() {
      chatArea.scrollTop = chatArea.scrollHeight;
    });
  }

  function setState(newState) {
    S.state = newState;
    micBtn.className = 'mic-btn' + (newState !== 'idle' ? ' ' + newState : '');
    micBtn.disabled = (newState === 'thinking');
  }

  function setStatus(text) {
    statusText.textContent = text;
    statusText.className = 'status-text' + (S.state !== 'idle' ? ' active' : '');
  }

  function updateTTSDot() {
    if (S.activeTTS === 'openai') {
      ttsDot.className = 'tts-dot green';
      ttsDot.title = 'OpenAI TTS Active';
    } else if (S.activeTTS === 'browser') {
      ttsDot.className = 'tts-dot yellow';
      ttsDot.title = 'Browser TTS Active';
    } else {
      ttsDot.className = 'tts-dot red';
      ttsDot.title = 'No TTS Active';
    }
  }

  function updateUI() {
    modeLabel.textContent = S.zeroMode ? 'THE COSMIC CLAW â ZERO MODE' : 'VOICE ASSISTANT';
    ttsEngineSelect.value = S.ttsEngine;
    voiceSelect.value = S.openaiVoice;
    autoListenToggle.className = 'toggle' + (S.autoListen ? ' on' : '');
    modelSelect.value = S.model;
    updateTTSDot();

    if (!S.sttSupported) {
      addMessage('system', 'Speech recognition not supported. Try Chrome on Android or desktop.');
    }
  }

  function hideAuth() {
    authScreen.classList.add('hidden');
  }

  // ===== EVENT LISTENERS =====
  function setupEventListeners() {
    // Auth
    authSubmit.addEventListener('click', function() {
      const key = apiKeyInput.value.trim();
      if (key) {
        S.apiKey = key;
        saveSettings();
      }
      hideAuth();
    });

    authSkip.addEventListener('click', hideAuth);

    apiKeyInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') authSubmit.click();
    });

    // Mic button
    micBtn.addEventListener('click', function() {
      if (S.state === 'listening') {
        try { S.recognition.stop(); } catch(e) {}
        setState('idle');
        setStatus('Tap mic to speak');
      } else if (S.state === 'speaking') {
        stopAllAudio();
        setState('idle');
        setStatus('Stopped. Tap mic to speak.');
      } else if (S.state === 'idle' || S.state === 'error') {
        startListening();
      }
    });

    // Stop button
    stopBtn.addEventListener('click', function() {
      stopAllAudio();
      setState('idle');
      setStatus('Stopped.');
    });

    // Clear chat
    clearBtn.addEventListener('click', function() {
      chatArea.innerHTML = '';
      S.conversationHistory = [];
      addMessage('system', 'Chat cleared.');
    });

    // Settings
    settingsBtn.addEventListener('click', function() {
      settingsApiKey.value = S.apiKey ? (S.apiKey.substring(0, 7) + '...') : '';
      settingsOverlay.classList.add('open');
    });

    closeSettings.addEventListener('click', function() {
      settingsOverlay.classList.remove('open');
    });

    settingsOverlay.addEventListener('click', function(e) {
      if (e.target === settingsOverlay) settingsOverlay.classList.remove('open');
    });

    ttsEngineSelect.addEventListener('change', function() {
      S.ttsEngine = this.value;
      saveSettings();
    });

    voiceSelect.addEventListener('change', function() {
      S.openaiVoice = this.value;
      saveSettings();
    });

    autoListenToggle.addEventListener('click', function() {
      S.autoListen = !S.autoListen;
      this.className = 'toggle' + (S.autoListen ? ' on' : '');
      saveSettings();
    });

    settingsApiKey.addEventListener('change', function() {
      const val = this.value.trim();
      if (val && val.startsWith('sk-')) {
        S.apiKey = val;
        saveSettings();
        this.value = val.substring(0, 7) + '...';
      }
    });

    modelSelect.addEventListener('change', function() {
      S.model = this.value;
      saveSettings();
    });

    // Prevent zoom on double-tap
    document.addEventListener('dblclick', function(e) { e.preventDefault(); });

    // Cleanup on page hide
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        stopAllAudio();
        if (S.state !== 'idle') setState('idle');
      }
    });
  }

  // ===== BOOT =====
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
</body>
</html>